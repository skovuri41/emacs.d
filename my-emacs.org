* Configuration
*** About this file
My emacs configuration based on org-mode literate programming style.
***** Credits
******* [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua]]
******* [[https://github.com/steckerhalter/steckemacs/blob/master/steckemacs.org][SteckEmacs]]
******* [[https://github.com/howardabrams/dot-files][Howard Abrams]]
******* [[http://www.emacswiki.org/emacs/][EmacsWiki]]
******* [[https://github.com/technomancy/emacs-starter-kit/tree/v2][emacs-starter-kit]]
******* [[erogemacs.org][ergoemacs]]
*** Emacs Initialization
***** Code
******* init.el
#+NAME: init.el
#+BEGIN_SRC emacs-lisp :tangle no
(package-initialize t)
(require 'org)
(require 'ob)
(require 'ob-tangle)
(require 'ob-clojure)
(setq org-babel-clojure-backend 'cider)
(org-babel-do-load-languages
 'org-babel-load-languages
 '((sh         . t)
   (js         . t)
   (emacs-lisp . t)
   (perl       . t)
   (scala      . t)
   (clojure    . t)
   (python     . t)
   (dot        . t)
   (css        . t)
   (plantuml   . t)))
(setq my-emacs-directory (file-name-directory (file-truename load-file-name)))
(setq org-confirm-babel-evaluate nil)
(org-babel-load-file (expand-file-name "my-emacs.org" my-emacs-directory))
(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(org-bullets-bullet-list (quote ("◉" "○" "►" "✿"))))
#+END_SRC
***** Personal Information
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Shyam Kovuri"
        user-mail-address "surya46584@gmail.com")
#+END_SRC
***** Always maximize Emacs
#+BEGIN_SRC emacs-lisp :tangle no 
(modify-all-frames-parameters '((fullscreen . maximized)))
#+END_SRC

This will maximize the current and all future Emacs frames. The parameter has been added in Emacs 24.4

***** Load Path
#+BEGIN_SRC emacs-lisp
(let ((default-directory "~/.emacs.d/elisp/"))
  (unless (file-exists-p default-directory)
    (make-directory default-directory))
  (add-to-list 'load-path default-directory))
#+END_SRC
Here we create the directory =~/.emacs.d/elisp= if it does not exist,
add it to the =load-path=.
Doing that any =.el= or =.elc= files in this directory can be required
from *emacs*.

***** Packages
#+BEGIN_SRC emacs-lisp

;;(setq package-archives nil)
;;(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
(add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)
(add-to-list 'package-archives 
             '("melpa-stable" . "http://melpa-stable.milkbox.net/packages/"))
;;(add-to-list 'package-pinned-packages '(cider . "melpa-stable") t)
;;(add-to-list 'package-pinned-packages '(ac-cider . "melpa-stable") t) 
;;(add-to-list 'package-pinned-packages '(clojure-mode . "melpa-stable") t) 

(when (not package-archive-contents)
    (package-refresh-contents))
    
(defun my-package-install (package &optional repository)
  "Install PACKAGE if it has not yet been installed.
   If REPOSITORY is specified, use that."
  (unless (package-installed-p package)
    (let ((package-archives (if repository
                                (list (assoc repository package-archives))
                              package-archives)))
    (package-install package))))

(my-package-install 'use-package)

(package-initialize)

(defvar my-packages '(rainbow-delimiters
  buffer-move
  ace-jump-mode
  ace-jump-buffer
  ace-window 
  jump-char
  deft
  clojure-mode
  smartparens
  zoom-frm
  flx-ido
  projectile
  helm
  helm-projectile
  helm-descbinds
  helm-gtags
  helm-swoop
  ipretty
  grizzl
  json-mode
  expand-region
  smex
  flyspell
  plantuml-mode
  org-journal
  ido-vertical-mode 
  yasnippet 
  clojure-snippets 
  cider 
  ac-cider
  org-bullets
  guide-key 
  smart-mode-line 
  undo-tree
  workgroups
  workgroups2
  clojure-cheatsheet
  helm-orgcard
  4clojure 
  iedit
  latest-clojure-libraries 
  company 
  zenburn-theme 
  drag-stuff 
  inf-mongo 
  bookmark+ 
  multiple-cursors
  magit
  git-blame
  git-commit-mode
  git-gutter-fringe
  git-messenger
  gitconfig-mode
  gitignore-mode
  htmlize 
  page-break-lines 
  direx 
  popwin
  )
 
 "A list of packages to ensure
 are installed at launch.")

(dolist (p my-packages)
  (when (not (package-installed-p p))
    (package-install p)))

#+END_SRC
The use-package declaration macro allows you to isolate package
configuration in your ".emacs" in a way that is performance-oriented
and,well, just tidy. 
#+BEGIN_SRC emacs-lisp
(require 'use-package)
#+END_SRC
Use =M-x package-refresh-contents= to reload the list of packages
after adding these for the first time.
*** Configuration
***** User Settings
#+BEGIN_SRC emacs-lisp
(when (file-readable-p "~/elisp/user.el") (load "~/elisp/user.el"))
#+END_SRC
***** Encoding
#+BEGIN_SRC emacs-lisp
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)
#+END_SRC
Kind of a sweeping blow to make sure UTF-8 is used everywhere.
***** General Settings
******* Backups
This is one of the things people usually want to change right away. By default, Emacs saves backup files in the current directory. 
These are the files ending in =~= that are cluttering up your directory lists. 
The following code stashes them all in =~/.emacs.d/backups=, where I can find them with =C-x C-f= (=find-file=) if I really need to.

#+begin_src emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+end_src
Disk space is cheap. Save lots.
#+begin_src emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list" t)))
#+end_src
******* History
#+begin_src emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(savehist-mode 1)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+end_src
******* Other Settings
#+BEGIN_SRC emacs-lisp
(setq
 inhibit-startup-message t
 require-final-newline t                ;auto add newline at the end of file
 column-number-mode t                   ;show the column number
 default-major-mode 'text-mode          ;use text mode per default
 mouse-yank-at-point t                  ;middle click with the mouse yanks at point
 history-length 250                     ;default is 30
 locale-coding-system 'utf-8            ;utf-8 is default
 tab-always-indent 'complete            ;try to complete before identing
 confirm-nonexistent-file-or-buffer nil ;don't ask to create a buffer
 vc-follow-symlinks t                   ;follow symlinks automatically
 recentf-max-saved-items 5000           ;same up to 5000 recent files
 eval-expression-print-length nil       ;do not truncate printed expressions
 eval-expression-print-level nil        ;print nested expressions
 send-mail-function 'sendmail-send-it
 kill-ring-max 5000                     ;truncate kill ring after 5000 entries
 mark-ring-max 5000                     ;truncate mark ring after 5000 entries
 mouse-autoselect-window t              ;window focus follows the mouse pointer
 mouse-wheel-scroll-amount '(1 ((shift) . 5) ((control))) ;make mouse scrolling smooth
 indicate-buffer-boundaries 'left       ;fringe markers
 split-height-threshold 110             ;more readily split horziontally
 enable-recursive-minibuffers t
 custom-unlispify-menu-entries nil      ;M-x customize should not cripple menu entries
 custom-unlispify-tag-names nil         ;M-x customize should not cripple tags
 show-paren-delay 0
 visible-bell t
 winner-mode 1)

(put 'narrow-to-region 'disabled nil)   ;narrow to region should be enabled by default
;;Suppress symbolic link warnings
(setq find-file-visit-truename t)

(setq bookmark-default-file  (concat user-emacs-directory "bookmarks"))
(require 'uniquify)

#+END_SRC
******* Default Settings
 #+BEGIN_SRC emacs-lisp
(setq-default
 tab-width 4
 indent-tabs-mode nil                   ;use spaces instead of tabs
 c-basic-offset 4                       ;"tab" with in c-related modes
 c-hungry-delete-key t                  ;delete more than one space
 )

#+END_SRC

Some variables like =tab-width= cannot be set globally:
#+BEGIN_QUOTE
tab-width is a variable defined in `C source code'.
...
Automatically becomes buffer-local when set.
#+END_QUOTE
Whenever they are set the value becomes buffer-local.
To be able to set such a variable globally we have to use
=setq-default= which modifies the default value of the variable.

******* Global Modes
#+BEGIN_SRC emacs-lisp

(global-auto-revert-mode 1)  ;auto revert buffers when changed on disk
(show-paren-mode t)          ;visualize()
(iswitchb-mode t)            ;use advanced tab switching
(blink-cursor-mode -1)       ;no cursor blinking
(tool-bar-mode -1)           ;disable the awful toolbar
(menu-bar-mode -1)           ;no menu, you can toggle it with C-c m
(scroll-bar-mode -1)         ;disable the sroll bar
(delete-selection-mode t)    ;enable delete by selection
;; Auto refresh buffers
(global-auto-revert-mode 0)
;; Also auto refresh dired, but be quiet about it
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)

#+END_SRC
******* Prompt Behavior
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)

(setq kill-buffer-query-functions
  (remq 'process-kill-buffer-query-function
         kill-buffer-query-functions))
#+END_SRC

All "yes" or "no" questions are aliased to "y" or "n". We don't really
want to type a full word to answer a question from Emacs, 
yet Emacs imposes that silly behavior on us. No!
Also Emacs should be able to kill processes without asking which is
achieved in the second expression. 
******* Starting Emacs with Bookmark
#+begin_src emacs-lisp :tangle no
(setq inhibit-splash-screen t)
;;(require 'bookmark)
(require 'bookmark+)
(bookmark-bmenu-list)
(switch-to-buffer "*Bookmark List*")
#+end_src
***** Themes,Faces,Frame

#+BEGIN_SRC emacs-lisp
(load-theme 'zenburn t)

#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
;;(set-face-attribute 'default nil :family "Bitstream Vera Sans Mono" :height 89)
;;(set-face-attribute 'default nil :family "Inconsolata" :height 120)
(set-default-font
     "-outline-Consolas-normal-r-normal-normal-14-97-96-96-c-*-iso8859-1")
#+END_SRC

*** Custom Functions
***** my-isearch-goto-match-beginning

#+BEGIN_SRC emacs-lisp
(defun my-isearch-goto-match-beginning ()
  (when (and isearch-forward (not isearch-mode-end-hook-quit)) (goto-char isearch-other-end)))
(add-hook 'isearch-mode-end-hook 'my-isearch-goto-match-beginning)
#+END_SRC

Make =isearch-forward= put the cursor at the start of the search, not the end, so that isearch can be used for navigation. 
See also http://www.emacswiki.org/emacs/IsearchOtherEnd.

***** show-file-name

#+BEGIN_SRC emacs-lisp
(defun show-file-name ()
  "Show the full path file name in the minibuffer."
  (interactive)
  (message (buffer-file-name))
  (kill-new (file-truename buffer-file-name)))
#+END_SRC

Display and copy the full path of the file associated with the current buffer to the kill ring.

***** switch-to-minibuffer-window

Sometimes the minibuffer loses focus and I almost can get back to it. This function does it quickly.

#+BEGIN_SRC emacs-lisp
(defun switch-to-minibuffer-window ()
  "Switch to minibuffer window (if active)."
  (interactive)
  (when (active-minibuffer-window)
    (select-window (active-minibuffer-window))))
#+END_SRC

***** toggle-window-split

#+BEGIN_SRC emacs-lisp
(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))
#+END_SRC

This function allows to get two vertically splitted windows into a horizontal split and back.
***** url-insert-file-contents

#+BEGIN_SRC emacs-lisp
(defun my-url-insert-file-contents (url)
  "Prompt for URL and insert file contents at point."
  (interactive "sURL: ")
  (url-insert-file-contents url))
#+END_SRC
***** nxml-functions
#+BEGIN_SRC emacs-lisp

(defun nxml-pretty-print-buffer ()
  "pretty print the XML in a buffer."
  (interactive)
  (nxml-pretty-print-region (point-min) (point-max)))

;; XML pretty print
(defun pretty-print-xml-region (begin end)
  (interactive "r")
  (save-excursion
    (nxml-mode)
    (goto-char begin)
    (while (search-forward-regexp "\>[ \\t]*\<" nil t)
      (backward-char) (insert "\n"))
    (indent-region begin end))
  (message "Ah, much better!"))

(defun nxml-kill-tag-contents ()
  "Copy the contents between two tags"
;  (interactive "*p\ncCopy tag contents: ") ; this expects arguments input
  (interactive)
  (nxml-backward-up-element)
  (kill-region
    (progn (search-forward ">")
      (point))
    (progn (nxml-backward-up-element)
      (nxml-forward-element)
      (search-backward "</")
      (point))))

(defun nxml-copy-tag-contents ()
  "Copy the contents between two tags"
;  (interactive "*p\ncCopy tag contents: ") ; this expects arguments input
  (interactive)
  (nxml-backward-up-element)
  (copy-region-as-kill
   (progn (search-forward ">") (point))
   (progn (nxml-backward-up-element)
     (nxml-forward-element)
     (search-backward "</")
     (point))))
#+end_src
***** move quickly functions
#+BEGIN_SRC emacs-lisp 
;;;;;;; Move more quickly
(global-set-key (kbd "C-S-n")
                (lambda ()
                  (interactive)
                  (ignore-errors (next-line 5))))

(global-set-key (kbd "C-S-p")
                (lambda ()
                  (interactive)
                  (ignore-errors (previous-line 5))))

(global-set-key (kbd "C-S-f")
                (lambda ()
                  (interactive)
                  (ignore-errors (forward-char 5))))

(global-set-key (kbd "C-S-b")
                (lambda ()
                  (interactive)
                  (ignore-errors (backward-char 5))))

#+END_SRC
***** lines functions
#+BEGIN_SRC emacs-lisp
;;; Open Lines

(defun open-line-below ()
  (interactive)
  (end-of-line)
  (newline)
  (indent-for-tab-command))

(defun open-line-above ()
  (interactive)
  (beginning-of-line)
  (newline)
  (forward-line -1)
  (indent-for-tab-command))

(defun goto-line-with-feedback ()
  "Show line numbers temporarily, while prompting for the line number input"
  (interactive)
  (unwind-protect
      (progn
        (linum-mode 1)
        (goto-line (read-number "Goto line: ")))
    (linum-mode -1)))

;;;;Join Lines
(defun join-lines ()
   "If at the end of the line, will join the following line to the
   end of this one...unless it is blank, in which case, it will
   keep joining lines until the next line with text is
   connected."
   (interactive)
   ;; Move to the the beginning of the white space before attempting
   ;; this process. This allows us to join lines even if we are in the
   ;; middle of some empty lines.
   (re-search-backward "[^[:space:]\\r\\n]")
   (forward-char)
   ;; Just in case we have some trailing whitespace we can't see, let's
   ;; just get rid of it. Won't do anything if in the middle of a line,
   ;; or if there is not trailing whitespace.
   (delete-trailing-whitespace (point) (point-at-eol))
   ;; While we are at the end of the line, join a line, remove the
   ;; whitespace, and keep on going until we're through...
   (while (eq (point-at-eol) (point))
     (delete-char 1)
     (delete-trailing-whitespace (point) (point-at-eol))))

;;;; copy-line with variable arugments
(defun copy-line (&optional arg)
  "Copy lines (as many as prefix argument) in the kill ring"
  (interactive "p")
  (kill-ring-save (line-beginning-position)
                  (line-beginning-position (+ 1 arg)))
  (message "%d line(s) copied" arg ))


#+END_SRC
***** emacs home directory
#+BEGIN_SRC emacs-lisp
(defun open-my-config-dir ()
  (interactive)
  (dired "~/.emacs.d"))
#+END_SRC
***** easier keyboard macro usage
#+BEGIN_SRC emacs-lisp
;; To facilitate easier keyboard macro usage (from http://www.emacswiki.org/emacs/KeyboardMacros)
(defun toggle-kbd-macro-recording-on ()
  "One-key keyboard macros: turn recording on."
  (interactive)
  (define-key global-map (this-command-keys)
    'toggle-kbd-macro-recording-off)
  (start-kbd-macro nil))

(defun toggle-kbd-macro-recording-off ()
  "One-key keyboard macros: turn recording off."
  (interactive)
  (define-key global-map (this-command-keys)
    'toggle-kbd-macro-recording-on)
  (end-kbd-macro))

#+END_SRC
***** helm-clojure-headlines

[[http://blog.jenkster.com/2013/10/a-tip-for-navigating-clojure-files-in-emacs.html][Navigating Clojure Files in Emacs]]

#+BEGIN_SRC emacs-lisp
(defun helm-clojure-headlines ()
  "Display headlines for the current Clojure file."
  (interactive)
  (helm-mode t)
  (helm :sources '(((name . "Clojure Headlines")
                    (volatile)
                    (headline "^[;(]")))))
#+END_SRC
***** reindent the whole buffer
#+BEGIN_SRC emacs-lisp
(defun reindent-whole-buffer ()
  "Reindent the whole buffer."
  (interactive)
  (indent-region (point-min)
                 (point-max)))
;;(global-set-key (kbd "M-Q") 'reindent-whole-buffer)

#+END_SRC
***** save macro to init file
#+BEGIN_SRC emacs-lisp
 (defun save-macro (name)                  
    "save a macro. Take a name as argument
     and save the last defined macro under 
     this name at the end of your .emacs"
     (interactive "SName of the macro :")  ; ask for the name of the macro    
     (kmacro-name-last-macro name)         ; use this name for the macro    
     (find-file user-init-file)            ; open ~/.emacs or other user init file 
     (goto-char (point-max))               ; go to the end of the .emacs
     (newline)                             ; insert a newline
     (insert-kbd-macro name)               ; copy the macro 
     (newline)                             ; insert a newline
     (switch-to-buffer nil))               ; return to the initial buffer

#+END_SRC
***** xah line or region functions
#+begin_src emacs-lisp :tangle yes

(defun xah-copy-line-or-region ()
  "Copy current line, or text selection.
When `universal-argument' is called first, copy whole buffer (but respect `narrow-to-region')."
  (interactive)
  (let (p1 p2)
    (if (null current-prefix-arg)
        (progn (if (use-region-p)
                   (progn (setq p1 (region-beginning))
                          (setq p2 (region-end)))
                 (progn (setq p1 (line-beginning-position))
                        (setq p2 (line-end-position)))))
      (progn (setq p1 (point-min))
             (setq p2 (point-max))))
    (kill-ring-save p1 p2)))

(defun xah-cut-line-or-region ()
  "Cut current line, or text selection.
When `universal-argument' is called first, cut whole buffer (but respect `narrow-to-region')."
  (interactive)
  (let (p1 p2)
    (if (null current-prefix-arg)
        (progn (if (use-region-p)
                   (progn (setq p1 (region-beginning))
                          (setq p2 (region-end)))
                 (progn (setq p1 (line-beginning-position))
                        (setq p2 (line-beginning-position 2)))))
      (progn (setq p1 (point-min))
             (setq p2 (point-max))))
    (kill-region p1 p2)))

(defun xah-copy-to-register-1 ()
  "Copy current line or text selection to register 1.
See also: `xah-paste-from-register-1', `copy-to-register'."
  (interactive)
  (let (p1 p2)
    (if (region-active-p)
        (progn (setq p1 (region-beginning))
               (setq p2 (region-end)))
      (progn (setq p1 (line-beginning-position))
             (setq p2 (line-end-position))))
    (copy-to-register ?1 p1 p2)
    (message "copied to register 1: %s." (buffer-substring-no-properties p1 p2))))

(defun xah-paste-from-register-1 ()
  "Paste text from register 1.
See also: `xah-copy-to-register-1', `insert-register'."
  (interactive)
  (when (use-region-p)
    (delete-region (region-beginning) (region-end) )
    )
  (insert-register ?1 t))


#+end_src

***** emacs switch next prev user buffer - xah
#+begin_src emacs-lisp :tangle yes
(defvar xah-switch-buffer-ignore-dired t "If t, ignore dired buffer when calling `xah-next-user-buffer' or `xah-previous-user-buffer'")
(setq xah-switch-buffer-ignore-dired t)

(defun xah-next-user-buffer ()
  "Switch to the next user buffer.
 “user buffer” is a buffer whose name does not start with “*”.
If `xah-switch-buffer-ignore-dired' is true, also skip directory buffer.
2015-01-05 URL `http://ergoemacs.org/emacs/elisp_next_prev_user_buffer.html'"
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (< i 20)
      (if (or
           (string-equal "*" (substring (buffer-name) 0 1))
           (if (string-equal major-mode "dired-mode")
               xah-switch-buffer-ignore-dired
             nil
             ))
          (progn (next-buffer)
                 (setq i (1+ i)))
        (progn (setq i 100))))))

(defun xah-previous-user-buffer ()
  "Switch to the previous user buffer.
 “user buffer” is a buffer whose name does not start with “*”.
If `xah-switch-buffer-ignore-dired' is true, also skip directory buffer.
2015-01-05 URL `http://ergoemacs.org/emacs/elisp_next_prev_user_buffer.html'"
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (< i 20)
      (if (or
           (string-equal "*" (substring (buffer-name) 0 1))
           (if (string-equal major-mode "dired-mode")
               xah-switch-buffer-ignore-dired
             nil
             ))
          (progn (previous-buffer)
                 (setq i (1+ i)))
        (progn (setq i 100))))))

(defun xah-next-emacs-buffer ()
  "Switch to the next emacs buffer.
 (buffer name that starts with “*”)"
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (and (not (string-equal "*" (substring (buffer-name) 0 1))) (< i 20))
      (setq i (1+ i)) (next-buffer))))

(defun xah-previous-emacs-buffer ()
  "Switch to the previous emacs buffer.
 (buffer name that starts with “*”)"
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (and (not (string-equal "*" (substring (buffer-name) 0 1))) (< i 20))
      (setq i (1+ i)) (previous-buffer))))
#+end_src

***** mark commands in transient mark mode

#+begin_src emacs-lisp :tangle yes
;; masteringemacs.org fixing mark commands tmm
(defun push-mark-no-activate ()
  "Pushes `point' to `mark-ring' and does not activate the region
   Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))

(defun jump-to-mark ()
  "Jumps to the local mark, respecting the `mark-ring' order.
  This is the same as using \\[set-mark-command] with the prefix argument."
  (interactive)
  (set-mark-command 1))

(defun exchange-point-and-mark-no-activate ()
  "Identical to \\[exchange-point-and-mark] but will not activate the region."
  (interactive)
  (exchange-point-and-mark)
  (deactivate-mark nil))
#+end_src


***** commands to navigate brackets, blocks and quote - xah 

#+begin_src emacs-lisp :tangle yes
(defvar xah-left-brackets nil "List of open bracket chars.")
(setq xah-left-brackets '("(" "{" "[" "<" "〔" "【" "〖" "〈" "《" "「" "『" "“" "‘" "‹" "«" "（"))

(defvar xah-right-brackets nil "list of close bracket chars.")
(setq xah-right-brackets '(")" "]" "}" ">" "〕" "】" "〗" "〉" "》" "」" "』" "”" "’" "›" "»" "）"))

(defun xah-backward-left-bracket ()
  "Move cursor to the previous occurrence of left bracket.
The list of brackets to jump to is defined by `xah-left-brackets'.
URL `http://ergoemacs.org/emacs/emacs_navigating_keys_for_brackets.html'
Version 2015-03-24"
  (interactive)
  (search-backward-regexp (eval-when-compile (regexp-opt xah-left-brackets)) nil t))

(defun xah-forward-right-bracket ()
  "Move cursor to the next occurrence of right bracket.
The list of brackets to jump to is defined by `xah-right-brackets'.
URL `http://ergoemacs.org/emacs/emacs_navigating_keys_for_brackets.html'
Version 2015-03-24"
  (interactive)
  (search-forward-regexp (eval-when-compile (regexp-opt xah-right-brackets)) nil t))

(defun xah-forward-block (&optional φn)
  "Move cursor forward to the beginning of next text block.
A text block is separated by blank lines.
In most major modes, this is similar to `forward-paragraph', but this command's behavior is the same regardless of syntax table."
  (interactive "p")
  (let ((φn (if (null φn) 1 φn)))
    (search-forward-regexp "\n[\t\n ]*\n+" nil "NOERROR" φn)))

(defun xah-backward-block (&optional φn)
  "Move cursor backward to previous text block.
See: `xah-forward-block'"
  (interactive "p")
  (let ((φn (if (null φn) 1 φn))
        (ξi 1))
    (while (<= ξi φn)
      (if (search-backward-regexp "\n[\t\n ]*\n+" nil "NOERROR")
          (progn (skip-chars-backward "\n\t "))
        (progn (goto-char (point-min))
               (setq ξi φn)))
      (setq ξi (1+ ξi)))))

#+end_src


***** org inline css hook
#+begin_src emacs-lisp :tangle yes
(defun my-org-inline-css-hook-1 (exporter)
  "Insert custom inline css"
  (when (eq exporter 'html)
    (let* ((dir (ignore-errors (file-name-directory (buffer-file-name))))
           (path (concat dir "style.css"))
           (homestyle (or (null dir) (null (file-exists-p path))))
           (final (if homestyle "~/.emacs.d/org-style.css" path)))
      (setq org-html-head-include-default-style nil)
      (setq org-html-head (concat
                           "<style type=\"text/css\">\n"
                           "<!--/*--><![CDATA[/*><!--*/\n"
                           (with-temp-buffer
                             (insert-file-contents final)
                             (buffer-string))
                           "/*]]>*/-->\n"
                           "</style>\n")))))

(defun my-org-inline-css-hook-2 (exporter)
  "Insert custom inline css"
  (when (eq exporter 'html)
    (let ((my-pre-bg (face-background 'default)))
      ;;(setq org-html-head-include-default-style nil)
      (setq org-html-head
            (format "<style type=\"text/css\">\n pre.src { background-color: %s;}</style>\n" my-pre-bg)))))


#+end_src


*** Advices

#+BEGIN_SRC emacs-lisp
(defadvice kill-ring-save (before slick-copy activate compile)
  "When called interactively with no active region, copy a single
line instead."
  (interactive
    (if mark-active (list (region-beginning) (region-end))
      (message "Copied line")
      (list (line-beginning-position)
               (line-beginning-position 2)))))

(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single
line instead."
  (interactive
    (if mark-active (list (region-beginning) (region-end))
      (list (line-beginning-position)
        (line-beginning-position 2)))))
#+END_SRC

*** Modes
***** ace-jump-buffer
***** ace-jump-mode
#+BEGIN_SRC emacs-lisp
  (require 'ace-jump-mode)
#+END_SRC
***** auto-complete
#+BEGIN_SRC emacs-lisp :tangle no
(require 'auto-complete-config)
(setq ac-delay 0.0)
(setq ac-quick-help-delay 0.5)
(add-to-list 'ac-dictionary-directories (concat user-emacs-directory "ac-dict"))
(set-default 'ac-sources
                 '(ac-source-abbrev
                   ac-source-dictionary
                   ac-source-yasnippet
                   ac-source-words-in-buffer
                   ac-source-words-in-same-mode-buffers
                   ac-source-semantic))

 (ac-config-default)
 (global-auto-complete-mode t)
#+END_SRC

Note that we specify where a dictionary lives for each specific
language, and if for some reason, a mode isn't getting the "AC"
minor mode, you can add to it with this magic:

#+BEGIN_SRC emacs-lisp :tangle no
  (dolist (m '(python-mode js2-mode clojure-mode))
    (add-to-list 'ac-modes m))
#+END_SRC
***** ace-window
#+begin_src emacs-lisp :tangle yes
(require 'ace-window)

#+end_src
***** bookmark+
#+begin_src emacs-lisp :tangle yes
(require 'bookmark+)
;;(setq bmkp-bmenu-state-file '~/.emacs-bmk-bmenu-state.el)
(setq bmkp-bmenu-state-file  (concat user-emacs-directory ".emacs-bmk-bmenu-state.el"))
(setq bmkp-bmenu-commands-file  (concat user-emacs-directory ".emacs-bmk-bmenu-commands.el"))
#+end_src
***** buffer-move
***** cider
 #+BEGIN_SRC emacs-lisp

 ;; pin CIDER to always use MELPA Stable
 ;; needs emacs 24.4
 ;;(add-to-list 'package-pinned-packages '(cider . "melpa-stable") t)
 ;;(add-to-list 'package-pinned-packages '(ac-cider . "melpa-stable") t) 
 ;;Enable eldoc in Clojure buffers:
 (require 'cider)
 (setq org-babel-clojure-backend 'cider)
 (add-hook 'cider-mode-hook #'eldoc-mode)
 
 ;;You can hide the *nrepl-connection* and *nrepl-server* buffers from
 ;;appearing in some buffer switching commands like switch-to-buffer(C-x b) like this:
 ;;(setq nrepl-hide-special-buffers t)

 ;;When using switch-to-buffer, pressing SPC after the command will make the hidden buffers visible.
 ;;They'll always be visible in list-buffers (C-x C-b).

 (setq cider-repl-tab-command 'indent-for-tab-command)

 (setq nrepl-log-messages t)

 ;;Prevent the auto-display of the REPL buffer in a separate window after connection is established:
 (setq cider-repl-pop-to-buffer-on-connect nil)

 ;;Stop the error buffer from popping up while working in buffers other than the REPL:
 ;(setq cider-popup-stacktraces nil)

 ;;Enable error buffer popping also in the REPL:
 ;(setq cider-repl-popup-stacktraces t)

 (setq cider-stacktrace-fill-column 80)

 ;;To auto-select the error buffer when it's displayed:
 (setq cider-auto-select-error-buffer nil)

 ;;The REPL buffer name has the format *cider-repl project-name*.
 ;;Change the separator from space to something else by overriding nrepl-buffer-name-separator.
 (setq nrepl-buffer-name-separator "-")

 ;;The REPL buffer name can also display the port on which the nREPL
 ;;server is running. 
 ;;Buffer name will look like cider-repl project-name:port.
 (setq nrepl-buffer-name-show-port t)
 
 ;;Make C-c C-z switch to the CIDER REPL buffer in the current window:
 (setq cider-repl-display-in-current-window t)
 
 ;;Limit the number of items of each collection the printer will print to 100:
 (setq cider-repl-print-length 100) ; the default is nil, no limit
 
 ;;Prevent C-c C-k from prompting to save the file corresponding to the buffer being loaded, if it's modified:
 ;;(setq cider-prompt-save-file-on-load nil)
 
 ;;Change the result prefix for REPL evaluation (by default there's no prefix):
 ;;(set cider-repl-result-prefix ";; => ")
 
 ;;And here's the result of that change:
 ;;user> (+ 1 2)
 ;; ;; => 3
 
 ;;Change the result prefix for interactive evaluation (by default it's =>):
 ;(set cider-interactive-eval-result-prefix ";; => ")
 ;;To remove the prefix altogether just set it to an empty string("").
 
 ;;Normally code you input in the REPL is font-locked with cider-repl-input-face (after you press RET) and results are font-locked with cider-repl-output-face.
 ;;If you want them to be font-locked as in clojure-mode use the following:
 ;(setq cider-repl-use-clojure-font-lock t)
 
 ;;You can control the C-c C-z key behavior of switching to the REPL buffer with the cider-switch-to-repl-command variable.
 ;;While the default command cider-switch-to-relevant-repl-buffer should be an adequate choice for most users,
 ;;cider-switch-to-current-repl-buffer offers a simpler alternative where CIDER will not attempt to match the
 ;;correct REPL buffer based on underlying project directories:
 ;(setq cider-switch-to-repl-command 'cider-switch-to-current-repl-buffer)
 
 ;;REPL History
 ;;To make the REPL history wrap around when its end is reached:
 (setq cider-repl-wrap-history t)
 
 ;;To adjust the maximum number of items kept in the REPL history:
 (setq cider-repl-history-size 1000) ; the default is 500
 
 ;;To store the REPL history in a file:
 (setq cider-repl-history-file "./cider-repl-history.txt")
 
 ;;Note that the history is written to the file when you kill the REPL buffer (which includes invoking cider-quit) or you quit Emacs.

 #+END_SRC

Auto completion configuration for Cider.

#+BEGIN_SRC emacs-lisp :tangle no
  (require 'ac-cider)
  (add-hook 'cider-mode-hook 'ac-flyspell-workaround)
  (add-hook 'cider-mode-hook 'ac-cider-setup)
  (add-hook 'cider-repl-mode-hook 'ac-cider-setup)
  (eval-after-load "auto-complete"
    '(add-to-list 'ac-modes 'cider-mode))
#+END_SRC

If you want to trigger auto-complete using TAB in CIDER buffers, you
may want to put  auto-complete into your completion-at-point-functions:

#+BEGIN_SRC emacs-lisp :tangle no
(defun set-auto-complete-as-completion-at-point-function ()
  (setq completion-at-point-functions '(auto-complete)))

(add-hook 'auto-complete-mode-hook 'set-auto-complete-as-completion-at-point-function)
(add-hook 'cider-mode-hook 'set-auto-complete-as-completion-at-point-function)

#+END_SRC

Integration with other modes

#+begin_src emacs-lisp
(add-hook 'cider-repl-mode-hook #'smartparens-strict-mode)
(add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode)
#+end_src


#+begin_src emacs-lisp :tangle yes
(defun cider-eval-last-sexp-and-append ()
  "Evaluate the expression preceding point and append result."
  (interactive)
  (let* ((last-sexp (if (region-active-p)
                       (buffer-substring (region-beginning) (region-end))
                     (cider-last-sexp)))
         (last-results (cider-eval-and-get-value last-sexp)))

    (with-current-buffer (current-buffer)
      (comment-indent)
      (insert " => ")
      (insert (prin1-to-string last-results)))))

(defun cider-send-and-evaluate-sexp ()
   "Sends the s-expression located before the point or the active
region to the REPL and evaluates it. Then the Clojure buffer is
activated as if nothing happened."
   (interactive)
   (if (not (region-active-p))
       (cider-insert-last-sexp-in-repl)
     (cider-insert-in-repl
      (buffer-substring (region-beginning) (region-end)) nil))
   (cider-switch-to-repl-buffer)
   (cider-repl-closing-return)
   (cider-switch-to-last-clojure-buffer)
   (message ""))


#+end_src

***** clojure-mode 
#+BEGIN_SRC emacs-lisp
;;(require 'subword-mode)
(require 'clojure-mode)
;;(require 'clojure-mode-extra-font-locking)
(add-hook 'clojure-mode-hook 'subword-mode)
(add-hook 'clojure-mode-hook 'rainbow-delimiters-mode)
(add-hook 'clojure-mode-hook 'smartparens-strict-mode)
(add-hook 'clojure-mode-hook 'turn-on-eldoc-mode)
#+END_SRC
***** clj-refactor
***** cljdoc
***** color-theme
***** company
#+BEGIN_SRC emacs-lisp
(require 'company)
(setq company-idle-delay 0.3)
(setq company-tooltip-limit 20)
(setq company-minimum-prefix-length 2)
(setq company-echo-delay 0)
;; (setq company-auto-complete nil)
;; (add-to-list 'company-backends 'company-dabbrev t)
;; (add-to-list 'company-backends 'company-ispell t)
;; (add-to-list 'company-backends 'company-files t)
(add-to-list 'company-backends 'company-yasnippet )
;;(setq company-backends (remove 'company-dabbrev company-backends))

;; (setq company-backends (remove 'company-ropemacs company-backends))
(global-company-mode 1)
#+END_SRC



#+BEGIN_SRC emacs-lisp :tangle no
(defun my-pcomplete-capf ()
  (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
(add-hook 'org-mode-hook #'my-pcomplete-capf)
#+END_SRC
This enables company completion for org-mode built-in commands and
tags.

***** desktop
#+BEGIN_SRC emacs-lisp :tangle yes
;; use only one desktop
(require 'desktop)
(setq desktop-path "~/.emacs.d/")
(setq desktop-dirname "~/.emacs.d/")
(setq desktop-base-file-name "emacs-desktop")

(setq desktop-buffers-not-to-save
        (concat "\\("
                "^nn\\.a[0-9]+\\|\\.log\\|(ftp)\\|^tags\\|^TAGS"
                "\\|\\.emacs.*\\|\\.diary\\|\\.newsrc-dribble\\|\\.bbdb"
	        "\\)$"))
(add-to-list 'desktop-modes-not-to-save 'dired-mode)
(add-to-list 'desktop-modes-not-to-save 'Info-mode)
(add-to-list 'desktop-modes-not-to-save 'info-lookup-mode)
(add-to-list 'desktop-modes-not-to-save 'fundamental-mode)

;; remove desktop after it's been read
(add-hook 'desktop-after-read-hook
	  '(lambda ()
	     ;; desktop-remove clears desktop-dirname
	     (setq desktop-dirname-tmp desktop-dirname)
	     (desktop-remove)
	     (setq desktop-dirname desktop-dirname-tmp)))

(defun saved-session ()
  (file-exists-p (concat desktop-dirname "/" desktop-base-file-name)))

;; use session-restore to restore the desktop manually
(defun desktop-session-restore ()
  "Restore a saved emacs session."
  (interactive)
  (if (saved-session)
      (desktop-read)
    (message "No desktop found.")))

;; use session-save to save the desktop manually
(defun desktop-session-save ()
  "Save an emacs session."
  (interactive)
  (if (saved-session)
      (if (y-or-n-p "Overwrite existing desktop? ")
	  (desktop-save-in-desktop-dir)
	(message "Session not saved."))
  (desktop-save-in-desktop-dir)))

;; ask user whether to restore desktop at start-up
(add-hook 'after-init-hook
	  '(lambda ()
	     (if (saved-session)
		 (if (y-or-n-p "Restore desktop? ")
		     (session-restore)))))

#+END_SRC
***** deft
#+BEGIN_SRC emacs-lisp 
(use-package deft
:commands deft
:init
(progn
(setq deft-extension "org"
 deft-directory "~/notes"
 deft-text-mode 'org-mode
 deft-use-filename-as-title t
 deft-auto-save-interval 20)
 (bind-key [f9] 'deft)))
#+END_SRC
***** diminish
#+BEGIN_SRC emacs-lisp
;; diminish modeline clutter
(require 'diminish)
(eval-after-load "yasnippet" '(diminish 'yas-minor-mode)) 
(eval-after-load "guide-key" '(diminish 'guide-key-mode))
(eval-after-load "smartparens" '(diminish 'smartparens-mode))
(eval-after-load "clojure-mode"
  '(defadvice clojure-mode (after clj-rename-modeline activate)
     (setq mode-name "Clj")))
(eval-after-load "eldoc" '(diminish 'eldoc-mode))
(eval-after-load "undo-tree" '(diminish 'undo-tree-mode))
(eval-after-load "helm-mode" '(diminish 'helm-mode))
;;(eval-after-load "workgroups2" '(diminish 'wg-mode))
(eval-after-load "workgroups" '(diminish 'workgroups-mode))
(eval-after-load "drag-stuff" '(diminish 'drag-stuff-mode))
(eval-after-load "page-break-lines" '(diminish 'page-break-lines-mode))

#+END_SRC
***** direx
#+begin_src emacs-lisp :tangle yes
(require 'direx)
;;(global-set-key (kbd "C-x C-j") 'direx:jump-to-directory)
;;(push '(direx:direx-mode :position left :width 40 :dedicated t)
;;      popwin:special-display-config)
(global-set-key (kbd "C-x C-j") 'direx:jump-to-directory-other-window)
#+end_src
***** drag-stuff
#+begin_src emacs-lisp :tangle yes
(require 'drag-stuff)
;;(drag-stuff-mode t)
(drag-stuff-global-mode t)
(add-to-list 'drag-stuff-except-modes 'org-mode)
#+end_src
***** eww
***** flx-ido
flx-ido quite recently which does indeed improve the flex matching.
#+BEGIN_SRC emacs-lisp 
(use-package flx-ido
 :init
 (progn
  (flx-ido-mode 1)
  (setq ido-use-faces nil)))
#+END_SRC
***** flycheck-mode
***** flyspell
spell checking with [[http://www.emacswiki.org/emacs/FlySpell][FlySpell]], which uses =ispell=.
To build a dictionary hash (seems important now), do this:

#+BEGIN_SRC sh :tangle no
  touch ~/.dictionary.txt
  buildhash ~/.dictionary.txt /usr/local/lib/english.aff ~/.dictionary.txt.hash
#+END_SRC

 Then, we can use it like:

#+BEGIN_SRC elisp
  (setq ispell-personal-dictionary
      (concat (getenv "HOME") "/.dictionary.txt"))

  (dolist (hook '(text-mode-hook org-mode-hook))
    (add-hook hook (lambda () (flyspell-mode 1))))
#+END_SRC

If I find any =text-mode= derived mode that I don't want to
spell-check, then I need to use the following:

#+BEGIN_SRC elisp :tangle no
  (dolist (hook '(change-log-mode-hook log-edit-mode-hook org-agenda-mode-hook))
    (add-hook hook (lambda () (flyspell-mode -1))))
#+END_SRC

***** grizzl
#+BEGIN_QUOTE
Grizzl is a small utility library to be used in other Elisp code
needing fuzzy search behaviour. 
It is optimized for large data sets, using a special type of lookup
table and supporting incremental searches 
(searches where the result can be narrowed-down by only searching what is already matched).
#+END_QUOTE

The source code for Grizzl can be found on [[https://github.com/d11wtq/grizzl][Github]]. It is written by Chris Corbyn who also wrote the PHP REPL =Boris=.

Currently it is used by [[https://github.com/bbatsov/projectile][Projectile]] in my config. I quite like Grizzl. It offers some benefits for when entries are longer. For most cases =IDO= is better suited though.

#+BEGIN_SRC emacs-lisp
(use-package grizzl)
(setq *grizzl-read-max-results* 30)
#+END_SRC

I would like to see more than just the default results of 10.
***** guide-key
#+BEGIN_SRC emacs-lisp
(require 'guide-key)
(setq guide-key/guide-key-sequence
      '("C-x r" "C-x 4" "C-x"
        (org-mode "C-c C-x")
        (outline-minor-mode "C-c @")))
(defun guide-key/my-hook-function-for-org-mode ()
  (guide-key/add-local-guide-key-sequence "C-c")
  (guide-key/add-local-guide-key-sequence "C-c C-x")
  (guide-key/add-local-highlight-command-regexp "org-"))
(add-hook 'org-mode-hook 'guide-key/my-hook-function-for-org-mode)
(setq guide-key/idle-delay 0.1)
(guide-key-mode 1)  ; Enable guide-key-mode
#+END_SRC
***** guide-key-tip
#+BEGIN_SRC emacs-lisp :tangle no
(require 'guide-key-tip)
(setq guide-key-tip/enabled t)
#+END_SRC
***** helm

#+BEGIN_QUOTE
Helm is incremental completion and selection narrowing framework for Emacs. 
It will help steer you in the right direction when you're looking for stuff in Emacs (like buffers, files, etc).

Helm is a fork of anything.el originaly written by Tamas Patrovic and can be considered to be its successor. 
Helm sets out to clean up the legacy code in anything.el and provide a cleaner, leaner and more modular tool, 
that's not tied in the trap of backward compatibility.
#+END_QUOTE

The Helm source code can be found [[https://github.com/emacs-helm/helm][at Github]].

You might want to checkout the [[https://github.com/emacs-helm/helm/wiki][Helm Wiki]] for detailed instructions on how Helm works.

#+BEGIN_SRC emacs-lisp
(use-package helm )
(use-package helm-descbinds )
(use-package helm-gtags )
(use-package helm-projectile)
(use-package helm-config)
(setq helm-mode-handle-completion-in-region nil) ; don't use helm for `completion-at-point'
(helm-mode 1)
(helm-gtags-mode 1)
(helm-descbinds-mode)
(setq helm-idle-delay 0.1)
(setq helm-input-idle-delay 0.1)
(setq helm-buffer-max-length 50)
(setq helm-M-x-always-save-history t)
(setq helm-buffer-details-flag nil)
(add-to-list 'helm-completing-read-handlers-alist '(org-refile)) ; helm-mode does not do org-refile well
(add-to-list 'helm-completing-read-handlers-alist '(org-agenda-refile)) ; same goes for org-agenda-refile

#+END_SRC
***** helm-google
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c h g") 'helm-google-suggest)

#+END_SRC
***** helm-swoop
#+BEGIN_SRC emacs-lisp
(require 'helm-swoop)

;; ;; Change keybinds to whatever you like 
(global-set-key (kbd "M-i") 'helm-swoop)
(global-set-key (kbd "M-I") 'helm-swoop-back-to-last-point)
(global-set-key (kbd "C-c M-i") 'helm-multi-swoop)
;; (global-set-key (kbd "C-x M-i") 'helm-multi-swoop-all)

;; ;; When doing isearch, hand the word over to helm-swoop
(define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
;; (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)

;; ;; Save buffer when helm-multi-swoop-edit complete
;; (setq helm-multi-swoop-edit-save t)

;; ;; If this value is t, split window inside the current window
(setq helm-swoop-split-with-multiple-windows t)

;; ;; Split direction. 'split-window-vertically or 'split-window-horizontally
(setq helm-swoop-split-direction 'split-window-horizontally)

;; ;; If nil, you can slightly boost invoke speed in exchange for text color
;; (setq helm-swoop-speed-or-color nil)

#+END_SRC

Edit mode

While doing helm-swoop type C-c C-e to enter the edit mode. Before
enter the edit mode, you can choose some lines marked by C-SPC or
M-SPC to edit. Apply changes to original buffer type C-x C-s.
***** htmlize
#+begin_src emacs-lisp :tangle yes
;;(setq org-export-htmlize-output-type 'css)
(setq htmlize-output-type 'inline-css)

;; From http://ruslanspivak.com/2007/08/18/htmlize-your-erlang-code-buffer/
 (defun my-htmlize-region (beg end)
   "Htmlize region and put into <pre> tag style that is left in <body> tag
    plus add font-size: 8pt"
    (interactive "r")
    (let* ((buffer-faces (htmlize-faces-in-buffer))
            (face-map (htmlize-make-face-map (adjoin 'default buffer-faces)))
             (pre-tag (format
                       "<pre style=\"%s font-size: 8pt\">"
                       (mapconcat #'identity (htmlize-css-specs
                                              (gethash 'default face-map)) " ")))
             (htmlized-reg (htmlize-region-for-paste beg end)))
     (switch-to-buffer-other-window "*htmlized output*")
                                   ; clear buffer
     (kill-region (point-min) (point-max))
                                     ; set mode to have syntax highlighting
     (web-mode)
     (save-excursion
       (insert htmlized-reg))
     (while (re-search-forward "<pre>" nil t)
       (replace-match pre-tag nil nil))
     (goto-char (point-min))))
#+end_src
***** ido-mode
#+BEGIN_EXAMPLE
Interactively do things with buffers and files
#+END_EXAMPLE

Great mode to quickly select buffers/files etc. Is built into Emacs since v22.

Select the previous match with =C-r= and next match with =C-s=.
To open =dired= at the current location press =C-d=.
Make a directory with =M-m=.

Use =C-j= if you want to create a file with what you have entered (and not the match).

#+BEGIN_SRC emacs-lisp
(setq ido-enable-flex-matching t
      ido-auto-merge-work-directories-length -1
      ido-create-new-buffer 'always
      ido-everywhere t
      ido-default-buffer-method 'selected-window
      ido-max-prospects 32
      ido-use-filename-at-point 'guess
      ido-vertical-define-keys 'C-n-C-p-up-and-down
      )
(ido-mode 1)
(ido-vertical-mode 1)

#+END_SRC
***** iedit
Iedit allows you to edit one occurrence of some text in a buffer
(possibly narrowed) or region, and simultaneously have other
occurrences edited in the same way, with visual feedback as you type.

#+BEGIN_SRC emacs-lisp
(require 'iedit)
(setq iedit-unmatched-lines-invisible-default t)
#+END_SRC
***** inf-mongo
#+begin_src emacs-lisp :tangle no
(require 'inf-mongo)
(setq inf-mongo-command "C://Program Files//MongoDB 2.6 Standard//bin//mongo.exe 127.0.0.1:27018")
#+end_src
***** ipretty
#+BEGIN_SRC emacs-lisp
(use-package ipretty 
:init
(progn
 (ipretty-mode t)))
#+END_SRC
***** json-mode
#+BEGIN_QUOTE
Major mode for editing JSON files.
Extends the builtin js-mode to add better syntax highlighting for JSON.
#+END_QUOTE

Github: https://github.com/joshwnj/json-mode

#+BEGIN_SRC emacs-lisp
(use-package json-mode)
(add-to-list 'auto-mode-alist '("\\.json\\'" . json-mode))
#+END_SRC

***** key-chord
#+begin_src emacs-lisp :tangle no
  (use-package key-chord
    :init
    (progn 
      (key-chord-mode 1)
      (key-chord-define-global "cg"     'undo)
      ;;(key-chord-define-global "yp"     'other-window)
      (setq key-chord-two-keys-delay 0.03)))
#+end_src
***** magit
#+begin_src emacs-lisp
 (require 'magit)

#+end_src
 I like having Magit to run in a /full screen/ mode, and took this
   =defadvice= idea from [[https://github.com/magnars/.emacs.d/blob/master/setup-magit.el][Sven Magnars]]:

#+BEGIN_SRC elisp
(defadvice magit-status (around magit-fullscreen activate)
  (window-configuration-to-register :magit-fullscreen)
  ad-do-it
  (delete-other-windows))
#+END_SRC
 Now, we have to have the =q= command recover the window session
 that was stored in a window register:

#+BEGIN_SRC elisp
(defun magit-quit-session ()
  "Restores the previous window configuration and kills the magit buffer"
  (interactive)
  (kill-buffer)
  (jump-to-register :magit-fullscreen))

(define-key magit-status-mode-map (kbd "q") 'magit-quit-session)
#+END_SRC
I install and use the [[https://github.com/syohex/emacs-git-gutter-fringe][Git Gutter Fringe]] as it works better with
windowing versions of Emacs.

#+BEGIN_SRC elisp
(if (autofeaturep 'git-gutter-fringe)
    (when (window-system)
        (require 'git-gutter-fringe)
        (global-git-gutter-mode +1)
        (setq-default indicate-buffer-boundaries 'left)
        (setq-default indicate-empty-lines +1)))
#+END_SRC
Git blame makes the history of a buffer pretty obvious... maybe a
tad too obvious.
Git Messenger shows the blame line as a popup.

#+BEGIN_SRC elisp
(when (autofeaturep 'git-blame)
  ;; (require 'git-blame)
  (autoload 'git-blame-mode "git-blame"
           "Minor mode for incremental blame for Git." t))

(when (autofeaturep 'git-messenger)
  (require 'git-messenger)
  (global-set-key (kbd "C-x v p") 'git-messenger:popup-message))
#+END_SRC
 Perhaps we can do Github pull requests from within Emacs, after
 reading [[http://endlessparentheses.com/merging-github-pull-requests-from-emacs.html][this blog entry]].

#+BEGIN_SRC elisp
(when (autofeaturep 'magit-gh-pulls-mode)
  (eval-after-load 'magit
    '(define-key magit-mode-map "#gg"
       (defun endless/load-gh-pulls-mode ()
         "Start `magit-gh-pulls-mode' only after a manual request."
         (interactive)
         (require 'magit-gh-pulls)
         (add-hook 'magit-mode-hook 'turn-on-magit-gh-pulls)
         (magit-gh-pulls-mode 1)
         (magit-gh-pulls-reload)))))
#+END_SRC
***** moe-theme
***** move-text
***** multiple-cursors
#+begin_src emacs-lisp :tangle yes

(require 'multiple-cursors)
(setq mc/list-file "~/.emacs.d/.mc-lists.el")


#+end_src
***** org-bullets
#+BEGIN_SRC emacs-lisp
(require 'org-bullets)
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+END_SRC
Additional bullets from [[http://nadeausoftware.com/articles/2007/11/latency_friendly_customized_bullets_using_unicode_characters][Customized Bullets]]  

***** org-mode
******* General Settings
#+BEGIN_SRC emacs-lisp
;;;; org-mode setup
(setq org-replace-disputed-keys t)
(setq org-return-follows-link t)
(add-to-list 'auto-mode-alist '("\\.txt$" . org-mode))
(add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
(add-hook 'org-mode-hook 'turn-on-auto-fill)
(setq org-directory "~/notes/")
(setq org-default-notes-file (concat org-directory "/notes.org"))
(setq org-agenda-include-all-todo t)
(setq org-agenda-include-diary t)
;(setq org-agenda-ndays 7)
(setq org-agenda-show-all-dates t)
(setq org-agenda-skip-deadline-if-done t)
(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-start-on-weekday nil)
(setq org-startup-indented t)
(setq org-hide-leading-stars t)
(setq org-odd-levels-only t)
;; alphabetical lists
(setq org-alphabetical-lists t)

(setq org-todo-keywords 
       '((sequence "TODO" 
                   "IN-PROGRESS"
                   "PENDING"
                   "CANCELLED"
                   "DONE")))

(defun set-org-mode-app-defaults ()
  (setq org-file-apps
	'(((auto-mode . emacs)
     ("\\.mm\\'" . default)
     ("\\.x?html?\\'" . system)
     ("\\.pdf\\'" . system)))))
(add-hook 'org-mode-hook 'set-org-mode-app-defaults)

(setq org-html-postamble nil)

;; Let's have pretty source code blocks
(setq org-edit-src-content-indentation 0
      org-src-tab-acts-natively t
      org-src-fontify-natively t
      org-confirm-babel-evaluate nil)
;; Make windmove work in org-mode:
(add-hook 'org-shiftup-final-hook 'windmove-up)
(add-hook 'org-shiftleft-final-hook 'windmove-left)
(add-hook 'org-shiftdown-final-hook 'windmove-down)
(add-hook 'org-shiftright-final-hook 'windmove-right)

#+END_SRC
******* Taking Notes
******* Agenda
******* Templates
#+BEGIN_SRC emacs-lisp :tangle yes
 (setq org-capture-templates 
	'(
    ;; capture bookmarks   
	  ("b" "Bookmark" plain (file "~/notes/bookmarks.org" "Bookmarks"))
	  ;; capture Tasks
   ("t" "Todo" entry (file+headline "~/notes/gtd.org" "Tasks")
             "* TODO %?\n  %i\n  %c")
	))

#+END_SRC
******* Speed Commands
If point is at the beginning of a headline or code block in
org-mode, single keys do fun things. See =org-speed-command-help=
for details (or hit the ? key at a headline).

#+BEGIN_SRC emacs-lisp
  (setq org-use-speed-commands t)
#+END_SRC

******* Managing Tasks
******* Clocking
******* org-journal
******* org-mobile-sync-mode

Set the name of the file where new notes will be stored

#+BEGIN_SRC emacs-lisp
  (setq org-mobile-inbox-for-pull "~/Dropbox/org/flagged.org")
#+END_SRC

Set to <your Dropbox root directory>/MobileOrg.

#+BEGIN_SRC emacs-lisp
  (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
#+END_SRC

To get this going, we just need to: =M-x org-mobile-push=
******* LaTeX
******* Publishing
#+begin_src emacs-lisp :tangle yes
(add-hook 'org-export-before-processing-hook 'my-org-inline-css-hook-2)
#+end_src

******* Babel
The trick to literate programming is in the [[http://orgmode.org/worg/org-contrib/babel/intro.html][Babel project]], which
allows org-mode to not only interpret source code blocks, but
evaluate them and tangle them out to a file.

#+BEGIN_SRC emacs-lisp :tangle no
(require 'ob-clojure)
(setq org-babel-clojure-backend 'cider)
(org-babel-do-load-languages
 'org-babel-load-languages
 '((sh         . t)
   (js         . t)
   (emacs-lisp . t)
   (perl       . t)
   (scala      . t)
   (clojure    . t)
   (python     . t)
   (dot        . t)
   (css        . t)
   (plantuml   . t)))
#+END_SRC

******* Local Key Bindings
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
          (lambda ()
            (local-set-key "\M-\C-n" 'outline-next-visible-heading)
            (local-set-key "\M-\C-p" 'outline-previous-visible-heading)
            (local-set-key "\M-\C-u" 'outline-up-heading)
            ;; table
            (local-set-key "\M-\C-w" 'org-table-copy-region)
            (local-set-key "\M-\C-y" 'org-table-paste-rectangle)
            (local-set-key "\M-\C-l" 'org-table-sort-lines)
            ;; display images
            (local-set-key "\M-I" 'org-toggle-iimage-in-org)))
#+END_SRC

A couple of short-cut keys to make it easier to edit text.

#+BEGIN_SRC emacs-lisp
  (defun org-text-bold () "Wraps the region with asterisks."
    (interactive)
    (surround-text "*"))
  (defun org-text-italics () "Wraps the region with slashes."
    (interactive)
    (surround-text "/"))
  (defun org-text-code () "Wraps the region with equal signs."
    (interactive)
    (surround-text "="))
#+END_SRC

******* org-crypt
#+begin_src emacs-lisp :tangle yes

(require 'org-crypt)
; Encrypt all entries before saving
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
; GPG key to use for encryption
(setq org-crypt-key "975EEA0A")
(setq org-crypt-disable-auto-save nil)

#+end_src

[[http://www.gpg4win.org/download.html][SoftwareGPG for Windows ]]

***** page-break-lines
#+begin_src emacs-lisp :tangle yes
(require 'page-break-lines)
(setq page-break-lines-modes
          '(emacs-lisp-mode
            lisp-mode
            scheme-mode
            compilation-mode
            outline-mode
            help-mode
            text-mode 
            clojure-mode
            Org))
 (global-page-break-lines-mode)
#+end_src

***** pkg-info
***** popwin
#+begin_src emacs-lisp :tangle yes
(require 'popwin)
(popwin-mode 1)
;;(setq display-buffer-function 'popwin:display-buffer)
;;(push '("^\*helm .+\*$" :regexp t) popwin:special-display-config)
;;(push '("^\*helm-.+\*$" :regexp t) popwin:special-display-config)
#+end_src
***** projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
:init
(progn 
 (setq projectile-completion-system 'grizzl)))
(projectile-global-mode)
#+END_SRC
Since indexing a big project is not exactly quick (especially in Emacs
Lisp), Projectile supports caching of the project's files. The caching
is enabled by default whenever native indexing is enabled.

#+BEGIN_SRC emacs-lisp
(setq projectile-enable-caching t)
#+END_SRC

***** rainbow-mode
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'rainbow-delimiters)
(dolist (hook '(css-mode-hook
                html-mode-hook
                js-mode-hook
                emacs-lisp-mode-hook
                text-mode-hook 
                cider-repl-mode-hook
                clojure-mode-hook
                ))
  (add-hook hook 'rainbow-delimiters-mode))

#+END_SRC
***** recentf
#+BEGIN_QUOTE
This package maintains a menu for visiting files that were operated on recently.  
When enabled a new "Open Recent" sub menu is displayed in the "File" menu.  
The recent files list is automatically saved across Emacs sessions.  
You can customize the number of recent files displayed, the location of the menu and others options (see the source code for details).
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(setq recentf-save-file (expand-file-name "~/.recentf"))
(recentf-mode 1)
(setq recentf-max-menu-items 25)

#+END_SRC
***** rich-minority
***** savehist
***** saveplace
#+BEGIN_QUOTE
Automatically save place in each file. This means when you visit a file, point goes to the last place
where it was when you previously visited the same file.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(require 'saveplace)
(setq-default save-place t)
#+END_SRC
***** smart-mode-line
#+BEGIN_SRC emacs-lisp
(require 'smart-mode-line)
(setq sml/no-confirm-load-theme t)
(sml/setup)
;;(sml/apply-theme 'dark)
;;(sml/apply-theme 'light)
;;(sml/apply-theme 'respectful)
(sml/apply-theme 'automatic)
;; Added in the right order, they even work sequentially:
;;(add-to-list 'sml/replacer-regexp-list '("^~/Dropbox/" ":DB:") t)
;;(add-to-list 'sml/replacer-regexp-list '("^:DB:Documents" ":DDocs:") t)

#+END_SRC
***** smartparens
#+BEGIN_QUOTE
Smartparens is minor mode for Emacs that deals with parens pairs and tries to be smart about it. 
It started as a unification effort to combine functionality of several existing packages in a single, 
compatible and extensible way to deal with parentheses, delimiters, tags and the like.
#+END_QUOTE

Github: https://github.com/Fuco1/smartparens
#+BEGIN_SRC emacs-lisp
(require 'smartparens)
(require 'smartparens-config)
;;(push 'org-mode sp-ignore-modes-list)
(add-to-list 'sp-ignore-modes-list  'Org )
(smartparens-global-mode t)
;; highlights matching pairs
(show-smartparens-global-mode t) 
(add-hook 'emacs-lisp-mode-hook 'smartparens-mode)
(add-hook 'emacs-lisp-mode-hook 'show-smartparens-mode)

(define-key sp-keymap (kbd "C--") 'sp-forward-sexp)
(define-key sp-keymap (kbd "C-=") 'sp-backward-sexp)

(define-key sp-keymap (kbd "C-.") 'sp-down-sexp)
(define-key sp-keymap (kbd "C-,") 'sp-backward-down-sexp)

(define-key sp-keymap (kbd "C-S-a") 'sp-beginning-of-sexp)
(define-key sp-keymap (kbd "C-S-e") 'sp-end-of-sexp)

(define-key sp-keymap (kbd "C-M-e") 'sp-up-sexp)
(define-key sp-keymap (kbd "C-M-a") 'sp-backward-up-sexp)

(define-key sp-keymap (kbd "C-M-n") 'sp-next-sexp)
(define-key sp-keymap (kbd "C-M-p") 'sp-previous-sexp)

(define-key sp-keymap (kbd "C-S-k") 'sp-kill-sexp)
;;-backward kill
(define-key sp-keymap (kbd "C-S-w") 'sp-copy-sexp)
;;-backward copy

(define-key sp-keymap (kbd "M-S-<backspace>") 'sp-unwrap-sexp)
(define-key sp-keymap (kbd "M-<backspace>") 'sp-backward-unwrap-sexp)

(define-key sp-keymap (kbd "M-t") 'sp-transpose-sexp)

(define-key sp-keymap (kbd "M-D") 'sp-splice-sexp)
(define-key sp-keymap (kbd "C-S-<backspace>") 'sp-splice-sexp-killing-forward)
(define-key sp-keymap (kbd "C-M-<backspace>") 'sp-splice-sexp-killing-backward)
(define-key sp-keymap (kbd "M-r") 'sp-splice-sexp-killing-around)

(define-key sp-keymap (kbd "C-<right>") 'sp-forward-slurp-sexp)
(define-key sp-keymap (kbd "C-<left>") 'sp-forward-barf-sexp)
(define-key sp-keymap (kbd "C-M-<left>") 'sp-backward-slurp-sexp)
(define-key sp-keymap (kbd "C-M-<right>") 'sp-backward-barf-sexp)

(define-key sp-keymap (kbd "C-S-f") 'sp-select-next-thing)
(define-key sp-keymap (kbd "C-S-b") 'sp-select-previous-thing)
(define-key sp-keymap (kbd "C-]") 'sp-select-next-thing-exchange)
(define-key sp-keymap (kbd "C-\\") 'sp-select-previous-thing-exchange)

(define-key sp-keymap (kbd "M-F") 'sp-forward-symbol)
(define-key sp-keymap (kbd "M-B") 'sp-backward-symbol)
(define-key sp-keymap (kbd "M-S-s") 'sp-split-sexp)
(define-key sp-keymap (kbd "M-S-m") 'sp-join-sexp)

(define-key sp-keymap (kbd "H-t") 'sp-prefix-tag-object)
(define-key sp-keymap (kbd "H-p") 'sp-prefix-pair-object)
(define-key sp-keymap (kbd "H-s c") 'sp-convolute-sexp)
(define-key sp-keymap (kbd "H-s a") 'sp-absorb-sexp)
(define-key sp-keymap (kbd "H-s e") 'sp-emit-sexp)
(define-key sp-keymap (kbd "H-s p") 'sp-add-to-previous-sexp)
(define-key sp-keymap (kbd "H-s n") 'sp-add-to-next-sexp)
(define-key sp-keymap (kbd "H-s j") 'sp-join-sexp)
(define-key sp-keymap (kbd "H-s s") 'sp-split-sexp)


#+END_SRC
***** smex
#+BEGIN_SRC elisp
  (require 'smex)
  (smex-initialize) ; Can be omitted. This might cause a (minimal) delay
  (global-set-key (kbd "M-x") 'smex)
  ;;(global-set-key (kbd "M-z") 'smex)  ;; Zap to char isn't so helpful
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)
  ;; This is our old M-x.
  ;;(global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
#+END_SRC***** sublime-theme
***** undo-tree
#+BEGIN_SRC emacs-lisp
(global-undo-tree-mode)

#+END_SRC

#+RESULTS:
: t
***** winner mode
You can save split-window config to register, like this:

Call window-configuration-to-register 【Ctrl+x r w】 (then give it a letter or digit as name).
Call jump-to-register 【Ctrl+x r j】 to restore a previously saved configuration.
Note: this doesn't work when you restart emacs, even if you have
desktop-save-mode on.
***** workgroups
https://github.com/tlh/workgroups.el

#+BEGIN_SRC emacs-lisp :tangle yes

(require 'workgroups)
(workgroups-mode 1)
;;(setq wg-prefix-key (kbd "C-c w"))
;;(wg-load "/path/to/saved/workgroups")

#+END_SRC


Workgroup creation:
Hit <prefix> c to issue the command wg-create-workgroup, give it a
name, hit RET, and a new workgroup is created.

Workgroup Switching:
<prefix> v issues the command wg-switch-to-workgroup. This will do a
completing-read (with ido if it's enabled) on the available workgroup
names, and switch to the workgroup with that name. <prefix> n will
switch to the workgroup rightward in the workgroups list from the
current workgroup, and <prefix> p will switch to the one leftward in
the list. <prefix> 0 through <prefix> 9 switch to the workgroup at
that position in the workgroups list. 

Morph:
You can toggle it off and on with <prefix> w (wg-toggle-morph), or
you can set the value of wg-morph-on to t or nil to turn it on or off
permenently.

Saving and Loading

Saving and loading was the original motivation for writing
Workgroups. You can save your workgroups to a file with <prefix> C-s
(wg-save) and you can load workgroups from a file with <prefix> C-l
(wg-load).
***** workgroups2
#+begin_src emacs-lisp :tangle no
(require 'workgroups2)
(workgroups-mode 1)
#+end_src
***** yasnippet
******* Installation
 #+BEGIN_SRC emacs-lisp
(require 'yasnippet)
(yas-reload-all)
(add-to-list 'yas-snippet-dirs (concat user-emacs-directory "snippets") t)
(dolist (hook '(prog-mode-hook text-mode-hook org-mode-hook clojure-mode-hook))
    (add-hook hook (lambda () (yas-minor-mode))))
#+END_SRC 
******* Org Mode Conflicts
#+BEGIN_SRC emacs-lisp
 (defun yas/org-very-safe-expand ()
            (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))
 (add-hook 'org-mode-hook
                    (lambda ()
                      (make-variable-buffer-local 'yas/trigger-key)
                      (setq yas/trigger-key [tab])
                      (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
                      (define-key yas/keymap [tab] 'yas/next-field)))
#+END_SRC
******* Merge two hooks for same mode into one
#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'web-mode-hook (lambda ()
  (yas-activate-extra-mode 'html-mode)
  (yas-activate-extra-mode 'css-mode) ))
#+END_SRC
***** zoom-frm
#+begin_src emacs-lisp :tangle yes

#+end_src

*** Key Bindings

#+BEGIN_SRC emacs-lisp
;; Use regex searches by default. 
(global-set-key (kbd "C-s") 'isearch-forward-regexp)
(global-set-key (kbd "C-r") 'isearch-backward-regexp)
(global-set-key (kbd "M-%") 'query-replace-regexp)
(global-set-key (kbd "C-M-s") 'isearch-forward)
(global-set-key (kbd "C-M-r") 'isearch-backward)
(global-set-key (kbd "C-M-%") 'query-replace)
;; switch buffers
(global-set-key (kbd "C-<tab>") 'next-buffer)
(global-set-key (kbd "<C-S-iso-lefttab>") 'previous-buffer)
;;; buffer swap
(global-set-key (kbd "<C-S-up>")     'buf-move-up)
(global-set-key (kbd "<C-S-down>")   'buf-move-down)
(global-set-key (kbd "<C-S-left>")   'buf-move-left)
(global-set-key (kbd "<C-S-right>")  'buf-move-right)
;; Window switching. (C-x o goes to the next window)
(windmove-default-keybindings) ;; Shift+direction
(global-set-key (kbd "C-x O") (lambda () (interactive) (other-window -1))) ;; back one
(global-set-key (kbd "C-x C-o") (lambda () (interactive) (other-window 2))) ;; forward two

(global-set-key (kbd "M-o")  'other-window)
;;; Ace Jump
(define-prefix-command 'ace-jump-map)
(global-set-key (kbd "M-j") 'ace-jump-map)
(define-key ace-jump-map (kbd "SPC") 'ace-jump-mode)
 ;;;;; Jump Char
(define-key ace-jump-map (kbd "f" ) 'jump-char-forward)
(define-key ace-jump-map (kbd "b" ) 'jump-char-backward)
;; ace window
(global-set-key (kbd "M-p")  'ace-window)
;;(global-set-key [(meta m)] 'jump-char-forward)
;;(global-set-key [(shift meta m)] 'jump-char-backward)

;;;;; expand region
(global-set-key (kbd "C-M-=") 'er/expand-region)
;;;; buffer related
(global-set-key (kbd "C-c y") 'bury-buffer)
(global-set-key (kbd "C-c r") 'revert-buffer)
;; Font size
(define-key global-map (kbd "C-+") 'text-scale-increase)
(define-key global-map (kbd "C--") 'text-scale-decrease)

(global-set-key (kbd "C-c i") 'indent-region)
;;(global-set-key (kbd "C-c l") 'linum-mode)
(global-set-key (kbd "C-c g") 'goto-line)
(global-set-key (kbd "C-c i") 'ibuffer)
(global-set-key (kbd "M-y") 'helm-show-kill-ring)
(global-set-key (kbd "C-x b") 'helm-mini)


;; Set keybindings for cycling buffers
(global-set-key [C-prior] 'previous-buffer)
(global-set-key [C-next] 'next-buffer)

;; Open Emacs config dir
;;(global-set-key (kbd "C-c e") 'open-my-config-dir)

; Quick keyboard macros with F1 (http://www.emacswiki.org/emacs/KeyboardMacros)
(global-set-key '[(f1)]          'call-last-kbd-macro)
(global-set-key '[(shift f1)]    'toggle-kbd-macro-recording-on)

;; Load and save desktops
(global-set-key (kbd "C-c d") 'desktop-session-restore)
(global-set-key (kbd "C-c D") 'desktop-session-save)

(global-set-key (kbd "M-J") 'join-lines)
(global-set-key (kbd "C-c o") 'open-line-below)
(global-set-key (kbd "C-c O") 'open-line-above)
(global-set-key "\C-c\C-k" 'copy-line)

(global-set-key [remap goto-line] 'goto-line-with-feedback)
(define-key global-map [remap goto-line] 'goto-line-with-feedback)

;; (global-set-key (kbd "<f2> c") 'cider-jack-in)
(eval-after-load 'cider
  '(define-key clojure-mode-map (kbd "<f2> c") 'cider-jack-in))

;; org-mode
;;(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cj" 'org-journal-entry)
(define-key global-map "\C-cc" 'org-capture)

;;multiple cursors

;;When you have an active region that spans multiple lines, 
;;the following will add a cursor to each line:

(global-set-key (kbd "C-c e") 'mc/edit-lines)

;;When you want to add multiple cursors not based on continuous lines, 
;;but based on keywords in the buffer, use:

(global-set-key (kbd "C-c n") 'mc/mark-next-like-this)
(global-set-key (kbd "C-c b") 'mc/mark-previous-like-this)
(global-set-key (kbd "C-c z") 'mc/mark-all-like-this)

(add-hook 'clojure-mode-hook
          (lambda ()
            (local-set-key (kbd "M-e") 'forward-sexp)
            (local-set-key (kbd "M-a") 'backward-sexp)
            (local-set-key (kbd "C-c C-v") 'cider-eval-last-sexp-and-append)
            (local-set-key (kbd "C-c C-S-v") 'cider-send-and-evaluate-sexp)))
;;magit
(global-set-key (kbd "M-C-g") 'magit-status)
 ;;(global-set-key (kbd "<f9> g") 'magit-status)

;;switch prev nex user buffers
(global-set-key (kbd "<f11>") 'xah-previous-user-buffer)
(global-set-key (kbd "<f12>") 'xah-next-user-buffer)

(global-set-key (kbd "<S-f11>") 'xah-previous-emacs-buffer)
(global-set-key (kbd "<S-f12>") 'xah-next-emacs-buffer)

(define-key global-map [remap exchange-point-and-mark] 'exchange-point-and-mark-no-activate)
(global-set-key (kbd "M-`") 'helm-all-mark-rings)
(global-set-key (kbd "C-`") 'push-mark-no-activate)

;;(global-set-key (kbd "C-x C-r") 'recentf-open-files)
(global-set-key (kbd "C-x C-r") 'helm-recentf)
(global-set-key (kbd "C-x C-f") 'helm-find-files)

;; keys for moving to prev/next code section (Form Feed; ^L)
;; form feed ^L by C-q then C-l
(global-set-key (kbd "<C-M-prior>") 'backward-page) ; Ctrl+Alt+PageUp
(global-set-key (kbd "<C-M-next>") 'forward-page)   ; Ctrl+Alt+PageDown

(global-set-key (kbd "<home>") 'xah-backward-left-bracket)
(global-set-key (kbd "<end>") 'xah-forward-right-bracket)

(global-set-key (kbd "<prior>") 'xah-backward-block) ; page up key
(global-set-key (kbd "<next>") 'xah-forward-block) ; page down key

#+END_SRC

* Work Items                                                          :emacs:

*** TODO text-increase and text-decrease conflict with smartparen key bindings
*** DONE goto-linum remap keybinding not working
*** DONE configure cider and lein, version 0.8 not working yet.
*** DONE cider newer version not working, missing package queue
*** DONE configure helm and projectile key bindings
*** TODO work on copy rectangle emacs-lisp script
*** TODO ido m-x mode and helm m-x mode , compare and research
*** TODO clj-refactor, cljdoc configuration
*** TODO Color Identifiers Mode
*** IN-PROGRESS checkout yasnippet, setup clojure yasnippet, org-capture yasnippet for links, compare with abbreva + skeleton available in emacs by default.
*** TODO emacs etags, usage study
*** DONE emacs start maximized disabled, revisit
*** IN-PROGRESS multiple cursors
*** DONE undo tree
